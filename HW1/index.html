<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="">
        <title>Практика 1</title>
    </head>
    <body>
        <div class="header">
            <h1>Лабораторная работа 3</h1>
        </div>
        <div class="table-of-contents">
            <h2>Оглавление</h2>
            <ul>
                <li><a href="#цель-работы">Цель работы</a></li>
                <li>
                    <a href="#обзор-используемых-библиотек">Обзор используемых библиотек</a>
                    <ul>
                        <li><a href="#psycopg2">psycopg2</a></li>
                        <li><a href="#sqlite3">sqlite3</a></li>
                        <li><a href="#duckdb">DuckDB</a></li>
                        <li><a href="#pandas">Pandas</a></li>
                        <li><a href="#sqlalchemy">SQLAlchemy</a></li>
                    </ul>
                </li>
                <li><a href="#метод-сравнения">Метод сравнения</a></li>
                <li><a href="#кодирование">Кодирование</a></li>
                <li><a href="#результаты">Результаты</a></li>
                <li><a href="#выводы">Выводы</a></li>
                <li><a href="#ссылки">Ссылки</a></li>
            </ul>
        </div>
        <div class="main">
            <div>
                <h2 id="цель-работы">Цель работы</h2>
                <p>
                    Целью данной работы было сравнить используемые в промышленной разработке библиотеки по работе с базами данных. Для успешного выполнения её было обозначено несколько задач:
                </p>
                <ul>
                    <li>Изучить методы определения производительности ПО для работы с БД</li>
                    <li>Изучить ключевые особенности работы выбранных для исследования библиотек</li>
                    <li>Написать программу, реализующую методы определения производительности, и с её помощью получить данные по производительности для каждой из библиотек</li>
                    <li>Полученные результаты сравнить и проанализировать</li>
                </ul>
            </div>
            <div>
                <h2 id="обзор-используемых-библиотек">Обзор исследуемых библиотек</h2>
                <p>Было выбрано 5 различных библиотек, которые позволяют взаимодействовать с базами данных в языке Python. Это:</p>
                <ol>
                    <li>psycopg2</li>
                    <li>sqlite3</li>
                    <li>DuckDB</li>
                    <li>Pandas</li>
                    <li>SQLAlchemy</li>
                </ol>
                <p>Коротко рассмотрим каждую из них.</p>
                <div>
                    <h3 id="psycopg2">psycopg2</h3>
                    <p>
                        Это минималистичная библиотека (драйвер) для работы с СУБД PostgreSQL из кода на Python. Она является достаточно тонкой прослойкой между программистом и API СУБД, так что с её помощью можно писать любые поддерживаемые Postgres запросы. Не отображает результаты запросов на объекты классов в Python.
                    </p>
                </div>
                <div>
                    <h3 id="sqlite3">sqlite3</h3>
                    <p>
                        sqlite3 представляет собой библиотеку для работы с СУБД SQLite. Особенность здесь заключается в самой СУБД, которая не использует отдельный сервер (как, к примеру, PostgreSQL), а хранит свои данные в отдельном <code>.db</code> файле, который может находиться в любом месте.
                    </p>
                </div>
                <div>
                    <h3 id="duckdb">DuckDB</h3>
                    <p>
                        DuckDB - легковесная СУБД, аналогичная по своему существу SQLite. Однако, в отличие от sqlite3, библиотека duckdb не включена в стандартный пакет Python и устанавливается отдельно.
                    </p>
                </div>
                <div>
                    <h3 id="pandas">Pandas</h3>
                    <p>
                        Pandas - библиотека для анализа данных, которая также позволяет исполнять запросы к СУБД. С ней можно использовать и серверные СУБД, как PostgreSQL, и встраиваемые, как SQLite. Pandas к общему функционалу исполнения запросов добавляет отображение результата запроса на свой класс DataFrame, предоставляющий удобный интерфейс для работы с табличными данными.
                    </p>
                </div>
                <div>
                    <h3 id="sqlalchemy">SQLAlchemy</h3>
                    <p>
                        SQLAlchemy - мощная ORM библиотека, позволяющая работать с различными СУБД, как реляционными, так и нет. Это значит, что она абстрагирует разработчика от написания простых запросов и перевода почти &#39;сырых&#39; данных из них в объекты классов (это важно, в условиях популярности подхода ООП в наше время). Однако слой ORM не позволяет писать сложные запросы (с использованием, например, аггригирующих функций), поэтому в SQLAlchemy оставлена возможность писать запросы в чистом виде и обрабатывать их &#39;руками&#39;.
                    </p>
                </div>
            </div>
            <div>
                <h2 id="метод-сравнения">Метод сравнения</h2>
                <p>
                    Для сравнения производительности библиотек использовалось 4 эталонных запроса к БД и датасет на 200 МБ. Запросы:
                </p>
                <ol>
                    <li><code>SELECT pickup_location_id, count(*) FROM data GROUP BY 1</code></li>
                    <li><code>SELECT passenger_count, avg(total_amount) FROM data GROUP BY 1</code></li>
                    <li><code>SELECT passenger_count, extract(year from tpep_pickup_datetime), count(*) FROM data GROUP BY 1, 2</code></li>
                    <li><code>SELECT passenger_count, extract(year from tpep_pickup_datetime), round(trip_distance) FROM data GROUP BY 1, 2, 3 ORDER BY 2, 3 DESC</code></li>
                </ol>
                <p>
                    Для запросов на SQLite и DuckDB немного изменялся синтаксис в 3 и 4 запросе, на общую семантику это не влияло.
                </p>
                <p>
                    Для каждого запроса засекалось время от исполнения предыдущей инструкции (первый клик секундомера) до исполнения следующей инструкции после выполнения запроса (второй клик секундомера). Каждая отсечка секундомера является количеством миллисекунд, прошедших с 1 Января 1970 года (стандартная дата начала эпохи для измерения временной отметки timestamp). Таким образом, временем на выполнение запроса считается разница между второй отсечкой и первой.
                </p>
                <p>
                    <img 
                        src="static/methods.png" 
                        alt="methods"
                        title="Фрагмент с заданием точки начала и конца отсчёта">
                </p>
                <p>
                    Для увеличения точности каждый из запросов повторялся 1000 раз, в результирующей статистике учитывалось медианное время в миллисекундах.
                </p>
                <p>
                    Измерение проводилось в неизолированной среде (на том же устройстве, где происходило написание кода для исследования), сам способ отсчёта времени не является наиболее точным, поскольку не учитывает возможности прерывания работы программы со стороны ОС, поэтому автор не претендует на эталонность исследования.
                </p>
            </div>
            <div>
                <h2 id="кодирование">Кодирование</h2>
                <p>
                    Код для анализа писался на языке Python версии 3.9.13. В первую очередь был написан профилировщик. Было решено использовать параметризованный декоратор, чтобы иметь возможность задавать необходимо число циклов запуска тестируемой функции. Возвращаемое значение функции игнорируется, вместо неё возвращается собранная статистика.
                </p>
                <p>
                    <img 
                        src="static/profiler.png" 
                        alt="profiler"
                        title="Код профилировщика">
                </p>
                <p>
                    После этого для каждой библиотеки были реализованы запросы, используемые в сравнении.
                </p>
                <p>
                    <img 
                        src="static/queries.png"
                        alt="queries-example"
                        title="Пример реализации 1 и 2 запроса для psycopg2">
                </p>
                <p>
                    Также были написаны функции для создания условий работы теста (подключение к СУБД) и cleanup-а (закрытие соединений).
                </p>
                <p>
                    Результаты тестов сохранялись в <code>.csv</code> файл, расположение которого настраивалось соответствующей переменной окружения, для открытости работы этим расположением была обозначена поддиректория проекта <code>artifacts</code>.
                </p>
                <p>
                    После сохранения на машине, файл для дальнейшего анализа выгружался в Deepnote (ссылка будет дана в конце отчёта).
                </p>
            </div>
            <div>
                <h2 id="результаты">Результаты</h2>
                <p>
                    Результаты сравнения оказались следующими:
                </p>
                <p>
                    <img 
                        src="static/data.png" 
                        alt="results"
                        title="Результаты сравнения">
                </p>
                <p>
                    Для автора достаточно удивительно, что DuckDB показал такие высокие показатели, в сравнении с остальными библиотеками. Причины этого остаются неясными, расследование показало, что работа функции не прерывалось ошибкой.
                </p>
                <p>
                    Более интересными тут являются показатели остальных 4-х библиотек. Как и ожидалось, запросы с использованием в качестве СУБД PostgreSQL оказались более эффективными ввиду больше приспособленности Postgres к использованию в условиях большого объёма данных. SQLite, хоть и является гораздо более легковесным, не обладает таких инструментов оптимизации запросов, которые позволили бы ему эффективно осуществлять операции на большом хранилище.
                </p>
                <p>
                    Из библиотек, использующих в качестве СУБД PostgreSQL, не вполне ясно, по какой причине SQLAlchemy сначала показал большую производительность, но её сравнительное снижение можно связать с наличием в архитектуре библиотеки ORM прослойки, которая тормозит использование более низкоуровневых инструментов.
                </p>
                <p>
                    В целом, результаты Pandas и psycopg2 показали достаточную эффективность, которая вполне очевидна исходя из практически полного отсутстивия оверхеда для работы с СУБД.
                </p>
            </div>
            <div>
                <h2 id="выводы">Выводы</h2>
                <p>
                    Выводом данной работы можно обозначить следующее:
                </p>
                <ul>
                    <li>Использование SQLAlchemy удобно при архитектуре приложения, подразумевающей частое применение стандартных CRUD операций над объектами с возможностью применения ООП и ORM и,отсутствии более сложных паттернов применения SQL запросов, в иных случаях лучше использовать Pandas или psycopg2</li>
                    <li>SQLite удобен в небольших приложениях, поскольку у него нет необходимости в настройки отдельного сервера.</li>
                    <li>DuckDB - интересная лошадка</li>
                </ul>
            </div>
            <div>
                <h2 id="ссылки">Ссылки</h2>
                <p>
                    <a href="https://deepnote.com/workspace/database-benchmarks-48f98c3e-966a-4293-990e-9fb861aa9ec9/project/4719f3ab-ec4f-4147-a20c-24511fa703f3/notebook/Databases%20Lab%203-d9e74b3a6d514756a3321aa070c51687?project-sidebar=project">Deepnote с анализом статистики</a>
                    <br>
                    <a href="https://github.com/luckyComet55/db-lab-3">Репозиторий с оригинальным отчётом в <code>.md</code> формате</a>
                </p>
            </div>
        </div>
    </body>
</html>